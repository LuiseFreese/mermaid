#!/usr/  .option('-s, --solution <name>', 'Solution name to create entities in (required for Dataverse creation)')
  .option('--dry-run', 'Preview the conversion without creating entities')
  .option('--verbose', 'Show detailed output')
  .option('--publisher-prefix <prefix>', 'Custom publisher prefix (default: mmd)', 'mmd')
  .option('--list-publishers', 'List available publishers before creating solution')
  .option('--no-create-publisher', 'Do not create publisher if it doesn\'t exist (fail instead)')env node

/*program
  .command('convert')
  .description('Convert a Mermaid ERD file to Dataverse entities')
  .option('-i, --input <file>', 'Input Mermaid ERD file path')
  .option('-o, --output <file>', 'Output JSON schema file (optional)')
  .option('-s, --solution <name>', 'Solution name to create entities in (required for Dataverse creation)')
  .option('--dry-run', 'Preview the conversion without creating entities')
  .option('--verbose', 'Show detailed output')
  .option('--publisher-prefix <prefix>', 'Custom publisher prefix (default: mmd)', 'mmd')
  .option('--list-publishers', 'List available publishers before creating solution')
  .option('--no-create-publisher', 'Do not create publisher if it doesn\'t exist (fail instead)')
  .action(async (options) => {aid to Dataverse Converter CLI
 * Main entry point for the application
 */

import { Command } from 'commander';
import { readFileSync, existsSync } from 'fs';
import { config } from 'dotenv';
import process from 'process';
import { MermaidERDParser } from './parser.js';
import { DataverseSchemaGenerator } from './schema-generator.js';
import { DataverseClient } from './dataverse-client.js';

// Load environment variables
config();

const program = new Command();

program
  .name('mermaid-to-dataverse')
  .description('Convert Mermaid ERD diagrams to Microsoft Dataverse tables and relationships')
  .version('1.0.0');

program
  .command('convert')
  .description('Convert a Mermaid ERD file to Dataverse entities')
  .option('-i, --input <file>', 'Input Mermaid ERD file path')
  .option('-o, --output <file>', 'Output JSON schema file (optional)')
  .option('-s, --solution <name>', 'Solution name to create entities in (required for Dataverse creation)')
  .option('--dry-run', 'Preview the conversion without creating entities')
  .option('--verbose', 'Show detailed output')
  .option('--publisher-prefix <prefix>', 'Custom publisher prefix (default: mmd)', 'mmd')
  .action(async (options) => {
    try {
      await convertMermaidToDataverse(options);
    } catch (error) {
      console.error('‚ùå Conversion failed:', error.message);
      if (options.verbose) {
        console.error(error.stack);
      }
      process.exit(1);
    }
  });

program
  .command('validate')
  .description('Validate a Mermaid ERD file syntax')
  .option('-i, --input <file>', 'Input Mermaid ERD file path')
  .action(async (options) => {
    try {
      await validateMermaidFile(options);
    } catch (error) {
      console.error('‚ùå Validation failed:', error.message);
      process.exit(1);
    }
  });

program
  .command('publishers')
  .description('List available publishers in Dataverse')
  .action(async (options) => {
    try {
      await listPublishers(options);
    } catch (error) {
      console.error('‚ùå Failed to list publishers:', error.message);
      process.exit(1);
    }
  });

program
  .command('config')
  .description('Show current configuration')
  .action(() => {
    showConfiguration();
  });

/**
 * Main conversion function
 * @param {Object} options - CLI options
 */
async function convertMermaidToDataverse(options) {
  console.log('üöÄ Mermaid to Dataverse Converter');
  console.log('================================\n');

  // Validate input
  if (!options.input) {
    throw new Error('Input file is required. Use -i or --input option.');
  }

  if (!existsSync(options.input)) {
    throw new Error(`Input file not found: ${options.input}`);
  }

  // Validate solution name for actual Dataverse operations (not for dry run or output only)
  if (!options.dryRun && !options.output && !options.solution) {
    throw new Error('Solution name is required for Dataverse operations. Use -s or --solution option.');
  }

  // Read and parse Mermaid file
  console.log(`üìñ Reading Mermaid ERD file: ${options.input}`);
  const mermaidContent = readFileSync(options.input, 'utf-8');

  console.log('üîç Parsing Mermaid ERD...');
  const parser = new MermaidERDParser();
  const erdData = parser.parse(mermaidContent);

  if (options.verbose) {
    console.log('üìã Parsed ERD Data:');
    console.log(`   Entities: ${erdData.entities.length}`);
    erdData.entities.forEach(entity => {
      console.log(`     - ${entity.name} (${entity.attributes.length} attributes)`);
    });
    console.log(`   Relationships: ${erdData.relationships.length}`);
    erdData.relationships.forEach(rel => {
      console.log(`     - ${rel.fromEntity} ${rel.cardinality.type} ${rel.toEntity}`);
    });
    console.log();
  }

  // Generate Dataverse schema
  console.log('üèóÔ∏è  Generating Dataverse schema...');
  const schemaGenerator = new DataverseSchemaGenerator();
  
  // Set custom publisher prefix if provided
  if (options.publisherPrefix) {
    schemaGenerator.publisherPrefix = options.publisherPrefix;
  }
  
  const schema = schemaGenerator.generateSchema(erdData);

  // Output schema to file if requested
  if (options.output) {
    const { writeFileSync } = await import('fs');
    writeFileSync(options.output, JSON.stringify(schema, null, 2));
    console.log(`üíæ Schema saved to: ${options.output}`);
    
    // If only outputting schema (no dry run), exit here
    if (!options.dryRun) {
      console.log('‚úÖ Schema export completed.');
      return;
    }
  }

  // If dry run, just show the schema and exit
  if (options.dryRun) {
    console.log('üîç DRY RUN MODE - Schema Preview:');
    console.log('=================================');
    
    console.log('\nüìä Entities to be created:');
    schema.entities.forEach(entity => {
      console.log(`   - ${entity.LogicalName} (${entity.DisplayName.LocalizedLabels[0].Label})`);
      if (entity.Attributes) {
        entity.Attributes.forEach(attr => {
          console.log(`     * ${attr.LogicalName} (${attr['@odata.type'].split('.').pop()})`);
        });
      }
    });

    console.log('\nüîó Relationships to be created:');
    schema.relationships.forEach(rel => {
      console.log(`   - ${rel.SchemaName} (${rel.RelationshipType})`);
    });

    console.log('\n‚úÖ Dry run completed. Use without --dry-run to create entities in Dataverse.');
    return;
  }

  // Create entities in Dataverse
  console.log('üåê Connecting to Dataverse...');
  
  const dataverseConfig = {
    dataverseUrl: process.env.DATAVERSE_URL,
    clientId: process.env.CLIENT_ID,
    clientSecret: process.env.CLIENT_SECRET,
    tenantId: process.env.TENANT_ID
  };

  // Validate configuration
  const missingConfig = Object.entries(dataverseConfig)
    .filter(([key, value]) => !value)
    .map(([key]) => key);

  if (missingConfig.length > 0) {
    throw new Error(`Missing required environment variables: ${missingConfig.join(', ')}`);
  }

  const client = new DataverseClient(dataverseConfig);

  console.log('üîê Authenticating...');
  await client.authenticate();
  console.log('‚úÖ Authentication successful');

  console.log('\nüèóÔ∏è  Creating entities and relationships...');
  const results = await client.createFromSchema(schema, {
    dryRun: false,
    verbose: options.verbose,
    solutionName: options.solution,
    publisherPrefix: options.publisherPrefix,
    listPublishers: options.listPublishers,
    createPublisher: options.createPublisher !== false // default true unless --no-create-publisher
  });

  // Final summary
  console.log('\nüéâ Conversion completed!');
  if (options.solution) {
    console.log(`   Solution: ${options.solution}`);
  }
  console.log(`   Entities created: ${results.entities.length}`);
  console.log(`   Relationships created: ${results.relationships.length}`);
  
  if (results.errors.length > 0) {
    console.log(`   Errors: ${results.errors.length}`);
    console.log('\n‚ö†Ô∏è  Some items could not be created. Check the logs above for details.');
  }

  console.log(`\nüåê Visit your Dataverse environment to see the created entities:`);
  console.log(`   ${dataverseConfig.dataverseUrl}`);
}

/**
 * Validate Mermaid file syntax
 * @param {Object} options - CLI options
 */
async function validateMermaidFile(options) {
  if (!options.input) {
    throw new Error('Input file is required. Use -i or --input option.');
  }

  if (!existsSync(options.input)) {
    throw new Error(`Input file not found: ${options.input}`);
  }

  console.log(`üîç Validating Mermaid ERD file: ${options.input}`);
  
  const mermaidContent = readFileSync(options.input, 'utf-8');
  const parser = new MermaidERDParser();
  
  try {
    const erdData = parser.parse(mermaidContent);
    
    console.log('‚úÖ Mermaid ERD file is valid!');
    console.log(`   Found ${erdData.entities.length} entities and ${erdData.relationships.length} relationships`);
    
    // Show detailed validation results
    console.log('\nüìä Entities:');
    erdData.entities.forEach(entity => {
      console.log(`   - ${entity.name}`);
      entity.attributes.forEach(attr => {
        const constraints = [];
        if (attr.isPrimaryKey) constraints.push('PK');
        if (attr.isForeignKey) constraints.push('FK');
        if (attr.isUnique) constraints.push('UK');
        if (attr.isRequired) constraints.push('Required');
        
        const constraintsStr = constraints.length > 0 ? ` (${constraints.join(', ')})` : '';
        console.log(`     * ${attr.name}: ${attr.type}${constraintsStr}`);
      });
    });

    console.log('\nüîó Relationships:');
    erdData.relationships.forEach(rel => {
      console.log(`   - ${rel.fromEntity} ${rel.cardinality.type} ${rel.toEntity}`);
    });

  } catch (error) {
    console.log('‚ùå Mermaid ERD file has syntax errors:');
    console.log(`   ${error.message}`);
    throw error;
  }
}

/**
 * List available publishers in Dataverse
 * @param {Object} options - CLI options
 */
async function listPublishers(options) {
  console.log('üìã Dataverse Publishers');
  console.log('=======================\n');

  // Get Dataverse configuration
  const dataverseConfig = {
    dataverseUrl: process.env.DATAVERSE_URL,
    clientId: process.env.CLIENT_ID,
    clientSecret: process.env.CLIENT_SECRET,
    tenantId: process.env.TENANT_ID
  };

  // Validate configuration
  const missingConfig = Object.entries(dataverseConfig)
    .filter(([key, value]) => !value)
    .map(([key]) => key);

  if (missingConfig.length > 0) {
    throw new Error(`Missing required environment variables: ${missingConfig.join(', ')}`);
  }

  const client = new DataverseClient(dataverseConfig);

  console.log('üîê Authenticating...');
  await client.authenticate();
  console.log('‚úÖ Authentication successful\n');

  console.log('üìã Fetching publishers...');
  const publishers = await client.getPublishers();

  if (publishers.length === 0) {
    console.log('   No publishers found in this environment.');
    return;
  }

  console.log('\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
  console.log('‚îÇ Available Publishers                                                           ‚îÇ');
  console.log('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§');
  console.log('‚îÇ Prefix  ‚îÇ Name                            ‚îÇ Description                         ‚îÇ');
  console.log('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§');

  publishers.forEach(pub => {
    const prefix = (pub.customizationprefix || '').substring(0, 7).padEnd(7);
    const name = (pub.friendlyname || '').substring(0, 31).padEnd(31);
    const desc = (pub.description || '').substring(0, 35).padEnd(35);
    console.log(`‚îÇ ${prefix} ‚îÇ ${name} ‚îÇ ${desc} ‚îÇ`);
  });

  console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
  
  console.log(`\n‚úÖ Found ${publishers.length} publishers`);
  console.log('\nTo use a specific publisher when creating a solution:');
  console.log('  node src/index.js convert --input your-file.mmd --solution YourSolution --publisher-prefix <prefix>');
}

/**
 * Show current configuration
 */
function showConfiguration() {
  console.log('‚öôÔ∏è  Current Configuration:');
  console.log('========================');
  
  const configs = [
    { name: 'Dataverse URL', env: 'DATAVERSE_URL', value: process.env.DATAVERSE_URL },
    { name: 'Client ID', env: 'CLIENT_ID', value: process.env.CLIENT_ID },
    { name: 'Client Secret', env: 'CLIENT_SECRET', value: process.env.CLIENT_SECRET ? '***' : undefined },
    { name: 'Tenant ID', env: 'TENANT_ID', value: process.env.TENANT_ID },
    { name: 'Solution Name', env: 'SOLUTION_NAME', value: process.env.SOLUTION_NAME || 'Not set' }
  ];

  configs.forEach(config => {
    const status = config.value ? '‚úÖ' : '‚ùå';
    const value = config.value || 'Not set';
    console.log(`${status} ${config.name}: ${value}`);
  });

  console.log('\nüí° Set these values in your .env file');
}

// Handle uncaught errors
process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught exception:', error.message);
  process.exit(1);
});

process.on('unhandledRejection', (error) => {
  console.error('‚ùå Unhandled rejection:', error.message);
  process.exit(1);
});

// Parse CLI arguments
program.parse();

// If no command provided, show help
if (!process.argv.slice(2).length) {
  program.outputHelp();
}
