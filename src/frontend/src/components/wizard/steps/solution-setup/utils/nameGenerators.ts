/**
 * Name Generation Utilities for Solution Setup
 * Handles auto-generation of internal names and prefixes from display names
 */

import { NameGenerationOptions, PUBLISHER_CONSTANTS, PUBLISHER_PATTERNS } from '../types';

/**
 * Generates an internal name from a display name
 * Removes spaces and special characters, optionally applies casing and length limits
 */
export const generateInternalName = (
  displayName: string,
  options: NameGenerationOptions = {}
): string => {
  if (!displayName?.trim()) {
    return '';
  }

  const {
    removeSpaces = true,
    removeSpecialChars = true,
    toLowerCase = false,
    maxLength,
    prefix = '',
    suffix = '',
  } = options;

  let result = displayName.trim();

  // Remove spaces if requested
  if (removeSpaces) {
    result = result.replace(/\s+/g, '');
  }

  // Remove special characters if requested (keep only letters and numbers)
  if (removeSpecialChars) {
    result = result.replace(/[^a-zA-Z0-9]/g, '');
  }

  // Apply case transformation
  if (toLowerCase) {
    result = result.toLowerCase();
  }

  // Add prefix and suffix
  result = prefix + result + suffix;

  // Apply length limit
  if (maxLength && result.length > maxLength) {
    result = result.substring(0, maxLength);
  }

  return result;
};

/**
 * Generates a publisher prefix from a name
 * Takes first characters, converts to lowercase, and ensures it meets prefix requirements
 */
export const generatePrefix = (name: string, maxLength: number = PUBLISHER_CONSTANTS.PREFIX_MAX_LENGTH): string => {
  if (!name?.trim()) {
    return '';
  }

  // Remove spaces and special characters, convert to lowercase
  const cleanName = name
    .trim()
    .replace(/[^a-zA-Z]/g, '')
    .toLowerCase();

  if (!cleanName) {
    return '';
  }

  // Take first characters up to maxLength
  let prefix = cleanName.substring(0, maxLength);

  // Ensure minimum length (pad with 'x' if necessary)
  while (prefix.length < PUBLISHER_CONSTANTS.PREFIX_MIN_LENGTH) {
    prefix += 'x';
  }

  return prefix;
};

/**
 * Validates an internal name against the required pattern
 */
export const validateInternalName = (name: string): boolean => {
  if (!name?.trim()) {
    return false;
  }

  // Must contain only letters and numbers
  return PUBLISHER_PATTERNS.UNIQUE_NAME.test(name);
};

/**
 * Validates a publisher prefix against the required pattern and length
 */
export const validatePrefix = (prefix: string): boolean => {
  if (!prefix?.trim()) {
    return false;
  }

  const trimmedPrefix = prefix.trim();

  // Check length requirements
  if (
    trimmedPrefix.length < PUBLISHER_CONSTANTS.PREFIX_MIN_LENGTH ||
    trimmedPrefix.length > PUBLISHER_CONSTANTS.PREFIX_MAX_LENGTH
  ) {
    return false;
  }

  // Must contain only lowercase letters
  return PUBLISHER_PATTERNS.PREFIX.test(trimmedPrefix);
};

/**
 * Generates a solution internal name from display name
 * Follows Dataverse naming conventions
 */
export const generateSolutionInternalName = (displayName: string): string => {
  return generateInternalName(displayName, {
    removeSpaces: true,
    removeSpecialChars: true,
    toLowerCase: false,
    maxLength: 64, // Dataverse solution name limit
  });
};

/**
 * Generates a publisher internal name from display name
 * Follows Dataverse naming conventions
 */
export const generatePublisherInternalName = (displayName: string): string => {
  return generateInternalName(displayName, {
    removeSpaces: true,
    removeSpecialChars: true,
    toLowerCase: false,
    maxLength: PUBLISHER_CONSTANTS.UNIQUE_NAME_MAX_LENGTH,
  });
};

/**
 * Cleans and validates a manually entered internal name
 */
export const cleanInternalName = (name: string): string => {
  if (!name) return '';
  
  // Remove invalid characters and trim
  return name.replace(/[^a-zA-Z0-9]/g, '').trim();
};

/**
 * Cleans and validates a manually entered prefix
 */
export const cleanPrefix = (prefix: string): string => {
  if (!prefix) return '';
  
  // Remove invalid characters, convert to lowercase, and trim
  return prefix
    .replace(/[^a-zA-Z]/g, '')
    .toLowerCase()
    .trim()
    .substring(0, PUBLISHER_CONSTANTS.PREFIX_MAX_LENGTH);
};

/**
 * Checks if a name is likely auto-generated based on common patterns
 */
export const isAutoGeneratedName = (displayName: string, internalName: string): boolean => {
  if (!displayName || !internalName) return false;
  
  const expectedGenerated = generateInternalName(displayName);
  return expectedGenerated === internalName;
};

/**
 * Suggests alternative names if the generated name conflicts with existing names
 */
export const suggestAlternativeName = (
  baseName: string,
  existingNames: string[],
  maxSuggestions: number = 5
): string[] => {
  const suggestions: string[] = [];
  const baseGenerated = generateInternalName(baseName);
  
  if (!existingNames.includes(baseGenerated)) {
    return [baseGenerated];
  }
  
  for (let i = 2; i <= maxSuggestions + 1; i++) {
    const suggestion = `${baseGenerated}${i}`;
    if (!existingNames.includes(suggestion)) {
      suggestions.push(suggestion);
    }
  }
  
  return suggestions;
};

/**
 * Suggests alternative prefixes if the generated prefix conflicts with existing prefixes
 */
export const suggestAlternativePrefix = (
  baseName: string,
  existingPrefixes: string[],
  maxSuggestions: number = 3
): string[] => {
  const suggestions: string[] = [];
  const basePrefix = generatePrefix(baseName);
  
  if (!existingPrefixes.includes(basePrefix)) {
    return [basePrefix];
  }
  
  // Try with different lengths
  for (let length = PUBLISHER_CONSTANTS.PREFIX_MIN_LENGTH; length <= PUBLISHER_CONSTANTS.PREFIX_MAX_LENGTH; length++) {
    const suggestion = generatePrefix(baseName, length);
    if (!existingPrefixes.includes(suggestion) && !suggestions.includes(suggestion)) {
      suggestions.push(suggestion);
      if (suggestions.length >= maxSuggestions) break;
    }
  }
  
  // If still no unique suggestions, add numbers
  if (suggestions.length === 0) {
    for (let i = 2; i <= maxSuggestions + 1; i++) {
      const suggestion = `${basePrefix.substring(0, PUBLISHER_CONSTANTS.PREFIX_MAX_LENGTH - 1)}${i}`;
      if (!existingPrefixes.includes(suggestion)) {
        suggestions.push(suggestion);
      }
    }
  }
  
  return suggestions;
};
